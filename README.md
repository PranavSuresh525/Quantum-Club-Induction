# Quantum-Club-Induction
I have attached the PS1 code with this repository. I have created a class to which describes all the operations in a qubit. I have defined each gate allong with its corresponding matrix. Since I cant use numpy, I decided to create a class, np which mimicks the necessary functions. I imported cmath and random to do this. Some of the functions include- square root, exponent function. All matrices are flattened to 1D matrix, basically arrays. The third function describes the process to create a identitiy matrix. The next function was a bit hard to create and i hard to search it up online, the kroner product. The basic operation involves the creation of the required ordered blank matrix as the result first. Then we run 4 for loops- 2 for each row and column of each matrix to multiply each element with the corresponding element in the second matrix. The next function also I had to take the help online,  describes the process to collaps the qubit using probability. We pick a random number using random. Then we run a for loop adding each probability as a cumilative probability. we check if the random number falls under each addition of a number. thus the result return a value which is the most probable. The last n-1 is to return last value in case all loops dont return a value. This concludes the class np. The next section describes the Quantum operations.

We start by defining Matrix multiplications with a vector. This starts with describing a new vector of the appropriate size. Then we run a simple for loop with multiplies the entire row of matrix A with every element of vector v. The next function is square matrix multiplication. I had to take help online for this too. This uses a similar process to the vector multiplication. A new vector is created in which each value is inputed by multiplying the appropriate value from the other matrices.The next function inside class is to create a matrix that describes the qubit. the function creates an 2^n by 1 matrix where n is the number of qubits. I have set the qubit to start as |00>. The apply gate function checks which qubit you want it to act on. If it is qubit 1 ( index[0] ) then it applies the kron product, i.e the Tensor product on qubit 1. This is mathematically gate ⊗ I. If it nneds to act on the second qubit ( index[1] ) it will apply I⊗gate. If the the function is a 2 qubit function, it checks the state the qubit is in and proceeds to apply a simple if else depending to on the control qubit. To swap the qubit value we first swap the postion of q1 and q2 then apply the gate to q2 then proceed to swap it back to return it to its original position. The last function is to measure the probabilities of each qubit. we just square the the eigen values for each qubit. then normalise it. we then return the value corresponding to the value picked by the normal function. since it pick a random number from 1-n we then need to convert it to dirac notation by converting it to binary. Thus we are able to create a program which can apply the gates 
